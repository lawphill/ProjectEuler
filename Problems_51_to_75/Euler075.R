# It turns out that 12 cm is the smallest length of wire that can be bent to form an integer sided right
#   angle triangle in exactly one way, but there are many more examples.

# 12 cm: (3,4,5)
# 24 cm: (6,8,10)
# 30 cm: (5,12,13)
# 36 cm: (9,12,15)
# 40 cm: (8,15,17)
# 48 cm: (12,16,20)

# In contrast, some lengths of wire, like 20 cm, cannot be bent to form an integer sided right angle
#   triangle, and other lengths allow more than one solution to be found; for example, using 120 cm it
#   is possible to form exactly three different integer sided right angle triangles.
# 120 cm: (30,40,50), (20,48,52), (24,45,51)

# Given that L is the length of the wire, for how many values of L â‰¤ 1,500,000 can exactly one integer
#   sided right angle triangle be formed?

gcd <- function(x,y) {
  r <- x%%y;
  return(ifelse(r, gcd(y, r), y))
}

# Euclid's formula for primitive pythagorean triplets
# So long as m & n are coprime, m > n, and m-n is odd, this will generate a unique primitive triplet
# non-primitives are generated by multipling by some constant k
# All triplets can be generated in this fashion
triplet <- function(m,n){
  if(n >= m){
    return(NA)
  }
  A <- m^2 - n^2
  B <- 2*m*n
  C <- m^2 + n^2
  return(sum(A,B,C))
}


add_to_counts <- function(start_m,start_n,max_L){
  for(m in start_m:865){ # 865 just happens to be the max to fit under the 1,500,000 limit
    if((m%%2) == 0){
      start_n <- 1
    }else{
      start_n <- 2
    }
    for(n in seq.int(start_n,(m-1),2)){
      perimeter <- triplet(m,n)
      if(perimeter > max_L){
        break
      }
      if(gcd(m,n)==1){
        counts[seq.int(perimeter,max_L,perimeter)] <<- counts[seq.int(perimeter,max_L,perimeter)] + 1
      }      
    }
  }
}

max_L <- 1500000L
counts <- rep(0,max_L)

add_to_counts(2,1,max_L)
print(sum(counts==1))