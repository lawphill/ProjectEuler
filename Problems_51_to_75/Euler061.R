# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal)
#   numbers and are generated by the following formulae:
  
#   Triangle   	P3,n=n(n+1)/2	 	1, 3, 6, 10, 15, ...
#   Square	 	P4,n=n2	 	1, 4, 9, 16, 25, ...
#   Pentagonal	 	P5,n=n(3n−1)/2	 	1, 5, 12, 22, 35, ...
#   Hexagonal	 	P6,n=n(2n−1)	 	1, 6, 15, 28, 45, ...
#   Heptagonal	 	P7,n=n(5n−3)/2	 	1, 7, 18, 34, 55, ...
#   Octagonal	 	P8,n=n(3n−2)	 	1, 8, 21, 40, 65, ...
#   The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

# The set is cyclic, in that the last two digits of each number is the first two digits of the next
#   number (including the last number with the first).
# Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is
#   represented by a different number in the set.
# This is the only set of 4-digit numbers with this property.
# Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type:
#   triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different
#   number in the set.

polygonal <- function(r,n){
  return((r-2) * (n*(n-1))/2 + n)
}

check_polys <- function(possible, polys){  
  in_polys <- lapply(3:8, function(z) which(possible %in% polys[[z]]))
  m <- matrix(data=FALSE,nrow=6,ncol=6)
  for(i in 1:6){
    m[i,in_polys[[i]]] <- TRUE
  }
  
  for(i in 1:6){
    if(!any(m[i,])){ return(FALSE) }
    if(!any(m[,i])){ return(FALSE) }
    
    if(sum(m[,i])>1){
      n <- m[m[,i],]
      if(all(sapply(2:2, function(i) all(n[i,] == n[1,])))){
        return(FALSE)
      }
    }
  }  
  return(TRUE)
}

min_num <- 1000
max_num <- 9999

# Generate polygonal numbers
polys <- list()
for(i in 3:8){
  l <- vector()
  x <- 1
  p <- polygonal(i,x)
  while(p < max_num){
    if(p > min_num){
      l <- c(l,p)
    }
    x <- x + 1
    p <- polygonal(i,x)
  }
  polys[[i]] <- unlist(l)
}

# The set is composed of 6 (not necessarily unique) digit pairs, each pair repeated twice.
all_poss <- sort(unique(unlist(polys)))
all_poss <- all_poss[((all_poss %/% 10) %% 10) != 0] # 3rd digit can't be 0
first_digits <- all_poss %/% 100
last_digits <- all_poss %% 100

next_poss <- list()
for(i in 1:length(last_digits)){
  next_poss[[i]] <- which(first_digits == last_digits[i])
}
x<-rep(0,6)
for(i in 1:length(all_poss)){
  possI <- next_poss[[i]]
  for(j in possI){
    possJ <- next_poss[[j]]
    for(k in possJ){
      possK <- next_poss[[k]]
      for(l in possK){
        possL <- next_poss[[l]]
        for(m in possL){
          possM <- next_poss[[m]]
          possM <- possM[last_digits[possM] == first_digits[i]] # Ensure then numbers wrap around
          for(n in possM){
            if(check_polys(all_poss[c(i,j,k,l,m,n)],polys) &
                 length(unique(c(i,j,k,l,m,n)))==6){
              if(!all(all_poss[c(i,j,k,l,m,n)] %in% x)){
                print(all_poss[c(i,j,k,l,m,n)])
                x<- all_poss[c(i,j,k,l,m,n)]
                print(sum(x))
              }
            }
          }
        }
      }
    }
  }
}

